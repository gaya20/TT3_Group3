{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./extension/common/mcafee_wb_helper.js","webpack:///./extension/common/mcafee_wb_utils.js","webpack:///./extension/common/mcafee_wb_webextension.js","webpack:///./extension/common/telemetry/mcafee_wb_screen_shown.js","webpack:///./extension/common/telemetry/mcafee_wb_whitelist.js","webpack:///./extension/js/background/mcafee_wb_autopausedata.js","webpack:///./extension/js/background/mcafee_wb_externalmsgdispatcher.js","webpack:///./extension/js/background/mcafee_wb_globalDispatchers.js","webpack:///./extension/js/background/mcafee_wb_globals.js","webpack:///./extension/js/background/mcafee_wb_tabdata.js","webpack:///./extension/js/common/mcafee_wb_constants.js","webpack:///./extension/js/common/mcafee_wb_externalextns.js","webpack:///./extension/js/common/mcafee_wb_localstorage.js","webpack:///./extension/ui/scripts/controllers/mcafee_wb_about_controller.js","webpack:///./extension/ui/scripts/controllers/mcafee_wb_autopause_controller.js","webpack:///./extension/ui/scripts/controllers/mcafee_wb_faq_controller.js","webpack:///./extension/ui/scripts/controllers/mcafee_wb_whitelist_controller.js","webpack:///./extension/ui/scripts/controllers/mcafee_wb_window_controller.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA,8BAA8B,2CAA2C,GAAG,wBAAwB,GAAG,wBAAwB,GAAG,iBAAiB;AACnJ;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,gHAA+C,IAAI;;AAEnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,IAAI;AAC3B;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACZA;AAAA,6CAAuE;;AAEvE;;;;;;;;;;;;;ACFA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACpCA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;ACpCA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;ACtGA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4GAAyD,wBAAwB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uHAAoE,UAAU;AAC9E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;AACA,6GAA0D,2BAA2B,GAAG,sCAAsC;AAC9H;AACA;AACA;AACA;AACA,+FAA4C,8BAA8B;AAC1E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,8GAA2D,8BAA8B;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+HAA4E,8BAA8B,KAAK,UAAU;AACzH;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0HAAuE,yBAAyB;AAChG;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;;;;;;;;;;;;;ACtPA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;ACTA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;ACbA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,6CAA6C;AAC3E;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA,uBAAuB,kCAAkC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1HA;AAAA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;ACfA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AClCA;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,uBAAuB,2BAA2B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oDAAoD,YAAY;AAChE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,+BAA+B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8FAAiC,uBAAuB;AACxD;;AAEA;AACA;AACA,8FAAiC,8BAA8B;;AAE/D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kGAAqC,sCAAsC;AAC3E,OAAO;;AAEP;AACA;AACA;AACA,kGAAqC,yBAAyB;AAC9D;;AAEA,kGAAqC,yBAAyB;AAC9D;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,8FAAiC,qBAAqB;AACtD;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8FAAiC,sBAAsB;AACvD;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8FAAiC,0BAA0B;AAC3D;;AAEA;AACA;AACA;AACA,8FAAiC,2CAA2C;AAC5E;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oCAAoC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kGAAqC,sCAAsC;AAC3E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8FAAiC,sCAAsC;AACvE;;AAEA;AACA;AACA;;AAEA,uBAAuB,oCAAoC;AAC3D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,oCAAoC;AAC3D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;ACzVA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;ACvBD;AAAA;AACA;AACiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;ACvOD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA,iDAAiD,EAAE;AACnD,6CAA6C,EAAE;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;AChCD;AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;;;;;;;;;;;;;;AC3HD;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yBAAyB;AACzB;AACA;AACA;AACA,GAAG;AACH,CAAC","file":"scripts/mcafee_wb_controllers.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import Globals from '../js/background/mcafee_wb_globals';\r\nimport LocalStorage from '../js/common/mcafee_wb_localstorage';\r\nimport Utils from './mcafee_wb_utils';\r\nimport TabData from '../js/background/mcafee_wb_tabdata';\r\nimport extension from './mcafee_wb_webextension';\r\nimport GlobalDispatchers from '../js/background/mcafee_wb_globalDispatchers';\r\n\r\n// All helper functions used across classes go here\r\nexport class Helper\r\n{\r\n  static isInArray(arr, value)\r\n  {\r\n    for (let index = 0; index < arr.length; ++index)\r\n    {\r\n      if (arr[index] === value)\r\n      {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  static resetTabData(tabId)\r\n  {\r\n    Globals.TabDataList.set(tabId, new TabData());\r\n    this.updateBadge(tabId);\r\n  }\r\n\r\n  // Updates browser action badge.\r\n  static updateBadge(tabId)\r\n  {\r\n    let currentBadgeCount = '';\r\n    const tabInfo = Globals.TabDataList.get(tabId);\r\n    if (tabInfo._videosPaused > 0)\r\n    {\r\n      currentBadgeCount = tabInfo._videosPaused.toString();\r\n    }\r\n    extension.browserAction.setBadgeText(\r\n      {\r\n        text: currentBadgeCount,\r\n        tabId\r\n      }\r\n    );\r\n  }\r\n\r\n  // get domain of a URL\r\n  static getDomainName(src)\r\n  {\r\n    return Utils.getDomainName(src);\r\n  }\r\n\r\n\r\n  static setAutoPauseData(srcvideo, paused, saved, whitelisted)\r\n  {\r\n    LocalStorage.setAutoPauseData(srcvideo, paused, saved, whitelisted);\r\n\r\n    const domain = Helper.getDomainName(srcvideo);\r\n    if (domain === '' || domain === undefined || domain === null)\r\n    {\r\n      return; // do not bother sending anything if the domain is empty\r\n    }\r\n    const webBoostMetrics = [{ UniqueIdentifier: 'WebBoost.Video.Pause' }, { 'Event.Value': paused }, { 'Event.Label': domain }, { Metric1: saved }];\r\n    // eslint-disable-next-line camelcase\r\n    const payload = { extension_id: extension.runtime.id, payload: webBoostMetrics };\r\n    const externalDispatcher = GlobalDispatchers.ExternalMsgDispatcher;\r\n    externalDispatcher\r\n      .sendExternalMessage(0, externalDispatcher._nativeCommands.AggregateData, payload);\r\n  }\r\n\r\n  static isWhitelisted(src)\r\n  {\r\n    Globals.logger.log(`Checking whether url ${src} is whitelisted`);\r\n\r\n    const wlistInfo = LocalStorage.getAutoPauseData(src);\r\n    const bWhitelisted = wlistInfo !== null && wlistInfo.IsWhiteListed;\r\n    return bWhitelisted;\r\n  }\r\n}\r\n\r\n// Get how far an element is from top left of the document\r\nexport const getBoundingCoordinates = function (element)\r\n{\r\n  const bounds = element.getBoundingClientRect();\r\n  const scrollTop = window.pageYOffset;\r\n  const scrollLeft = window.pageXOffset;\r\n  const top = Math.round(bounds.top + scrollTop);\r\n  const left = Math.round(bounds.left + scrollLeft);\r\n  const bottom = Math.round(bounds.bottom + scrollTop);\r\n  const right = Math.round(bounds.right + scrollLeft);\r\n  return {\r\n    top, left, bottom, right\r\n  };\r\n};\r\n","export default class Utils\r\n{\r\n  static getDomainName(src)\r\n  {\r\n    let url = src;\r\n    if (!/^(https?:|chrome:|about:)/.test(src))\r\n    {\r\n      url = `https://${src}`;\r\n    }\r\n    const link = new URL(url);\r\n    return link.hostname.startsWith('www.') ? link.hostname.substr(4) : link.hostname;\r\n  }\r\n}\r\n","const extension = WEBPACK_BROWSER_TYPE === 'chrome' ? chrome : browser; // eslint-disable-line no-undef\r\n\r\nexport default extension;\r\n","/* eslint-disable camelcase */\r\n// WebBoost_Screen_Shown\r\nconst TelemetryScreenShown = function ()\r\n{\r\n  this.elements = {};\r\n  this.elements.name = 'WebBoostScreenShown';\r\n  this.elements.interaction_type = 'Main';\r\n  this.elements.browser = 'UNKNOWN';\r\n  this.elements.browser_action_count = 'default';\r\n  this.elements._event_name = 'WebBoost_Screen_Shown';\r\n  this.name = function name(val)\r\n  {\r\n    this.elements.name = val.toString();\r\n    return this;\r\n  };\r\n  this.interaction_type = function interaction_type(val)\r\n  {\r\n    this.elements.interaction_type = val.toString();\r\n    return this;\r\n  };\r\n  this.browser = function browser(val)\r\n  {\r\n    this.elements.browser = val.toString();\r\n    return this;\r\n  };\r\n  this.browser_action_count = function browser_action_count(val)\r\n  {\r\n    this.elements.browser_action_count = val.toString();\r\n    return this;\r\n  };\r\n  this.serialize = function serialize()\r\n  {\r\n    return JSON.stringify(this.elements);\r\n  };\r\n};\r\n\r\nexport default TelemetryScreenShown;\r\n","/* eslint-disable camelcase */\r\n//\r\nconst TelemetryWhitelist = function ()\r\n{\r\n  this.elements = {};\r\n  this.elements.name = 'WebBoostWhitelist';\r\n  this.elements.interaction_type = 'Add';\r\n  this.elements.browser = 'Unknown';\r\n  this.elements.domain = 'default';\r\n  this.elements._event_name = 'WebBoost_Whitelist';\r\n  this.name = function name(val)\r\n  {\r\n    this.elements.name = val.toString();\r\n    return this;\r\n  };\r\n  this.interaction_type = function interaction_type(val)\r\n  {\r\n    this.elements.interaction_type = val.toString();\r\n    return this;\r\n  };\r\n  this.browser = function browser(val)\r\n  {\r\n    this.elements.browser = val.toString();\r\n    return this;\r\n  };\r\n  this.domain = function domain(val)\r\n  {\r\n    this.elements.domain = val.toString();\r\n    return this;\r\n  };\r\n  this.serialize = function serialize()\r\n  {\r\n    return JSON.stringify(this.elements);\r\n  };\r\n};\r\n\r\nexport default TelemetryWhitelist;\r\n","// gets information regarding the default whitelist\r\nexport default class AutoPauseData\r\n{\r\n  //  Has to fetch this json from SA server later so a callback\r\n  static getAutoPauseData(fcallback)\r\n  {\r\n    const autoPauseData = [\r\n      {\r\n        BandWidthSaved: 0, IsWhiteListed: true, Url: 'youtube.com', VideosPaused: 0, UserModified: false\r\n      },\r\n      {\r\n        BandWidthSaved: 0, IsWhiteListed: true, Url: 'netflix.com', VideosPaused: 0, UserModified: false\r\n      },\r\n      {\r\n        BandWidthSaved: 0, IsWhiteListed: true, Url: 'microsoft.com', VideosPaused: 0, UserModified: false\r\n      },\r\n      {\r\n        BandWidthSaved: 0, IsWhiteListed: true, Url: 'webex.com', VideosPaused: 0, UserModified: false\r\n      },\r\n      {\r\n        BandWidthSaved: 0, IsWhiteListed: true, Url: 'bluejeans.com', VideosPaused: 0, UserModified: false\r\n      },\r\n      {\r\n        BandWidthSaved: 0, IsWhiteListed: true, Url: 'zoom.us', VideosPaused: 0, UserModified: false\r\n      },\r\n      {\r\n        BandWidthSaved: 0, IsWhiteListed: true, Url: 'zoho.com', VideosPaused: 0, UserModified: false\r\n      },\r\n      {\r\n        BandWidthSaved: 0, IsWhiteListed: true, Url: 'gotomeeting.com', VideosPaused: 0, UserModified: false\r\n      },\r\n      {\r\n        BandWidthSaved: 0, IsWhiteListed: true, Url: 'clickmeeting.com', VideosPaused: 0, UserModified: false\r\n      },\r\n      {\r\n        BandWidthSaved: 0, IsWhiteListed: true, Url: 'vonage.com', VideosPaused: 0, UserModified: false\r\n      },\r\n      {\r\n        BandWidthSaved: 0, IsWhiteListed: true, Url: 'adobe.com', VideosPaused: 0, UserModified: false\r\n      },\r\n      {\r\n        BandWidthSaved: 0, IsWhiteListed: true, Url: 'intermedia.net', VideosPaused: 0, UserModified: false\r\n      },\r\n      {\r\n        BandWidthSaved: 0, IsWhiteListed: true, Url: 'ringcentral.com', VideosPaused: 0, UserModified: false\r\n      },\r\n      {\r\n        BandWidthSaved: 0, IsWhiteListed: true, Url: 'evoice.com', VideosPaused: 0, UserModified: false\r\n      },\r\n      {\r\n        BandWidthSaved: 0, IsWhiteListed: true, Url: 'u.cyberlink.com', VideosPaused: 0, UserModified: false\r\n      },\r\n      {\r\n        BandWidthSaved: 0, IsWhiteListed: true, Url: 'digium.com', VideosPaused: 0, UserModified: false\r\n      },\r\n      {\r\n        BandWidthSaved: 0, IsWhiteListed: true, Url: 'slack.com', VideosPaused: 0, UserModified: false\r\n      },\r\n      {\r\n        BandWidthSaved: 0, IsWhiteListed: true, Url: 'skype.com', VideosPaused: 0, UserModified: false\r\n      },\r\n      {\r\n        BandWidthSaved: 0, IsWhiteListed: true, Url: 'twitch.tv', VideosPaused: 0, UserModified: false\r\n      },\r\n      {\r\n        BandWidthSaved: 0, IsWhiteListed: true, Url: 'sharepoint.com', VideosPaused: 0, UserModified: false\r\n      },\r\n      {\r\n        BandWidthSaved: 0, IsWhiteListed: true, Url: 'mixer.com', VideosPaused: 0, UserModified: false\r\n      },\r\n      {\r\n        BandWidthSaved: 0, IsWhiteListed: true, Url: 'pluralsight.com', VideosPaused: 0, UserModified: false\r\n      }\r\n\r\n    ];\r\n\r\n    const xhr = new XMLHttpRequest();\r\n    xhr.open('GET', 'https://www.siteadvisor.com/webboost/defaultwhitelist.json', true);\r\n    xhr.responseType = 'json';\r\n    xhr.onreadystatechange = function onreadystatechange()\r\n    {\r\n      // only process completed state\r\n      if (xhr.readyState === 4 && xhr.status === 200)\r\n      {\r\n        try\r\n        {\r\n          fcallback(false, xhr.response !== null ? xhr.response : autoPauseData);\r\n        }\r\n        catch (exception)\r\n        {\r\n          fcallback(true, autoPauseData);\r\n        }\r\n      }\r\n    };\r\n\r\n    xhr.onerror = function onerror()\r\n    {\r\n      fcallback(true, autoPauseData);\r\n    };\r\n\r\n    xhr.send();\r\n  }\r\n}\r\n","/* eslint-disable class-methods-use-this */\r\n/* eslint-disable no-restricted-syntax */\r\n/* eslint-disable camelcase */\r\n// Send messages to whitelisted extension, if it is not available then lets\r\n// try and send message to the native component\r\nimport Globals from './mcafee_wb_globals';\r\nimport extension from '../../common/mcafee_wb_webextension';\r\nimport Constants from '../common/mcafee_wb_constants';\r\n\r\nexport default class ExternalMsgDispatcher\r\n{\r\n  constructor()\r\n  {\r\n    this._externalCommands = {\r\n      PING: 0\r\n    };\r\n    this._responseCommands = {\r\n      PONG: 0\r\n    };\r\n    this._nativeCommands = {\r\n      LogMsg: 6,\r\n      HandshakeGreeting: 9,\r\n      AggregateData: 11,\r\n      Telemetry: 14\r\n    };\r\n    this._extensionCommands = {\r\n      HandshakeGreeting: 8\r\n    };\r\n\r\n    this._extPort = null;\r\n  }\r\n\r\n  init()\r\n  {\r\n    const message = {\r\n      request_type: this._externalCommands.PING,\r\n      payload: {}\r\n    };\r\n    this._sendExtnMsg(Globals.EXTERNAL_EXTNS.get('WebAdvisor'), message);\r\n  }\r\n\r\n  // ======== Methods below are for messages going out to WA extension or native ==========\r\n\r\n  _isvalidRequestType(request_type)\r\n  {\r\n    let valid = false;\r\n    for (const type in this._externalCommands)\r\n    {\r\n      if (this._externalCommands[type] === request_type)\r\n      {\r\n        valid = true;\r\n      }\r\n    }\r\n\r\n    for (const type in this._nativeCommands)\r\n    {\r\n      if (this._nativeCommands[type] === request_type)\r\n      {\r\n        valid = true;\r\n      }\r\n    }\r\n\r\n    return valid;\r\n  }\r\n\r\n  _validateMsg(request_type, payload)\r\n  {\r\n    if (\r\n      request_type === undefined\r\n      || payload === undefined\r\n      || !this._isvalidRequestType(request_type)\r\n    )\r\n    {\r\n      Globals.logger.logLocal('Invalid msg to be sent externally');\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  sendExternalMessage(id, request_type, payload)\r\n  {\r\n    if (!this._validateMsg(request_type, payload))\r\n    {\r\n      return;\r\n    }\r\n\r\n    const message = {\r\n      id,\r\n      request_type,\r\n      payload\r\n    };\r\n\r\n    // send message to WA extension\r\n    if (!this._extPort)\r\n    {\r\n      try\r\n      {\r\n        this._sendExtnMsg(Globals.EXTERNAL_EXTNS.get('WebAdvisor'), message);\r\n      }\r\n      catch (e)\r\n      {\r\n        Globals.logger.logLocal(`Sending external msg: ${JSON.stringify(message)}`);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      // send message to native directly\r\n      try\r\n      {\r\n        this._extPort.postMessage(message);\r\n      }\r\n      catch (e)\r\n      {\r\n        this._extPort = null;\r\n        Globals.logger.logLocal(`Error sending message to native: ${e.message}`);\r\n      }\r\n    }\r\n  }\r\n\r\n  logMsg(logDetails)\r\n  {\r\n    this.sendExternalMessage(0, this._nativeCommands.LogMsg,\r\n      {\r\n        process_type: (logDetails.processType === 0) ? 'ct' : 'bg',\r\n        browser_type: logDetails.browserType,\r\n        extension_type: logDetails.extensionType,\r\n        log_level: logDetails.logLevel,\r\n        msg: logDetails.msg\r\n      });\r\n  }\r\n\r\n  // =============== Methods below are for messages coming in from native ===============\r\n\r\n  _processNativeMessage(nativeMessage)\r\n  {\r\n    Globals.logger.log(`Processing message from binary: ${nativeMessage.request_type} ${JSON.stringify(nativeMessage.payload)}`);\r\n    switch (nativeMessage.request_type)\r\n    {\r\n    case this._extensionCommands.HandshakeGreeting:\r\n      this._handleNativeSettings(nativeMessage.payload.settings);\r\n      Globals.logger.log(`Binary version: ${nativeMessage.payload.version}`);\r\n      break;\r\n    default:\r\n      break;\r\n    }\r\n  }\r\n\r\n  _handleNativeSettings(settingsObj)\r\n  {\r\n    if (settingsObj === undefined)\r\n    {\r\n      return;\r\n    }\r\n\r\n    // set logger to native logger if needed\r\n    const useNativeLogger = settingsObj[Constants.UseNativeLogger];\r\n    if (useNativeLogger)\r\n    {\r\n      Globals.useNativeLogger = true;\r\n      Globals.logger.setNativeLoggingEnabled(true, 1);\r\n    }\r\n  }\r\n\r\n  _disconnectNative()\r\n  {\r\n    if (!this._extPort)\r\n    {\r\n      return;\r\n    }\r\n\r\n    this._extPort.disconnect();\r\n    // set port back to null so msgs can now be sent through WA instead\r\n    this._extPort = null;\r\n  }\r\n\r\n  _connectNative()\r\n  {\r\n    this._extPort = extension.runtime.connectNative('siteadvisor.mcafee.chrome.extension');\r\n    if (this._extPort === null)\r\n    {\r\n      return;\r\n    }\r\n\r\n    this._extPort.onDisconnect.addListener(() =>\r\n    {\r\n      Globals.logger.log('Failed to make connection or we got disconnected from native');\r\n      this._extPort = null;\r\n    });\r\n\r\n    this._extPort.onMessage.addListener((jsonNativeMsg) =>\r\n    {\r\n      if (!('request_type' in jsonNativeMsg && 'id' in jsonNativeMsg && 'payload' in jsonNativeMsg))\r\n      {\r\n        Globals.logger.log(`Invalid native json message: ${JSON.stringify(jsonNativeMsg)} `);\r\n        return;\r\n      }\r\n      try\r\n      {\r\n        this._processNativeMessage(jsonNativeMsg);\r\n      }\r\n      catch (e)\r\n      {\r\n        Globals.logger.log(`Native json message may be missing some keys: ${JSON.stringify(jsonNativeMsg)} + ${e.message} `);\r\n      }\r\n    });\r\n\r\n    const manifestInfo = extension.runtime.getManifest();\r\n    this._extPort.postMessage(\r\n      {\r\n        id: 0,\r\n        request_type: this._nativeCommands.HandshakeGreeting,\r\n        payload:\r\n            {\r\n              extn_version: manifestInfo.version,\r\n              browser_type: 2,\r\n              user_agent: navigator.userAgent,\r\n              extn_id: extension.runtime.id\r\n            }\r\n      }\r\n    );\r\n  }\r\n\r\n  _sendExtnMsg(extnId, message)\r\n  {\r\n    extension.runtime.sendMessage(extnId,\r\n      message,\r\n      (response) =>\r\n      {\r\n        // Handle things if WA extension or other extension is not enabled,\r\n        // try to connect to native directly\r\n        if (!response)\r\n        {\r\n          // Connect to native\r\n          this._connectNative();\r\n          return;\r\n        }\r\n\r\n        // Handle things if WA extension or other extension is enabled\r\n        Globals.logger.log(`Message received in external dispatcher: ${JSON.stringify(response)}`);\r\n        if (response.useNativeLogger)\r\n        {\r\n          Globals.useNativeLogger = true;\r\n          Globals.logger.setNativeLoggingEnabled(true, 1);\r\n        }\r\n      });\r\n  }\r\n}\r\n","// The global objects for background script that needs to be persisted\r\n// and shared for the instance of the browser\r\nimport ExternalMsgDispatcher from './mcafee_wb_externalmsgdispatcher';\r\n\r\n//  The global objects used in background across multiple objects\r\nconst GlobalDispatchers = {\r\n  ExternalMsgDispatcher: new ExternalMsgDispatcher()\r\n};\r\n\r\nexport default GlobalDispatchers;\r\n","// The global objects for background script that needs to be persisted\r\n// and shared for the instance of the browser\r\nimport ExternalExtns from '../common/mcafee_wb_externalextns';\r\n\r\n//  The global objects used in background across multiple objects\r\nconst Globals = {\r\n  TabDataList: new Map(),\r\n  logger: null,\r\n  useNativeLogger: false,\r\n  MEDIA_PATTERN: new RegExp('\\\\.(mp3|MP3|mpeg|MPEG|mp4|MP4|mp2t|MP2T|ogv|OGV|ogx|OGX|ogg|OGG|webm|WEBM)', 'i'),\r\n  EXTERNAL_EXTNS: new ExternalExtns()\r\n};\r\n\r\nexport default Globals;\r\n","//  Data related to tab stored for each tab\r\nexport default class TabData\r\n{\r\n  constructor()\r\n  {\r\n    this._blockedUrls = [];\r\n    this._lastClickTime = 0;\r\n    this._lastClickCoordinates = { x: 0, y: 0 };\r\n    this._videosPaused = 0;\r\n    this._m3u8MasterFileList = [];\r\n    // whether bg has notified content script it has found a live video in the tab\r\n    this._liveVideoNotified = false;\r\n    this._whitelistedFrameIds = [];\r\n    this._hlsUserClickedPlay = [];\r\n    this._responses = new Map(); // The responses received in onHeaderReceived is stored here.\r\n    this._responseCacheVideos = new Set();\r\n    this._claimData = new Map();\r\n  }\r\n\r\n  addResponse(url, init, response)\r\n  {\r\n    this._responses.set(url, { initiator: init, responseHeaders: response });\r\n  }\r\n\r\n  getResponse(url)\r\n  {\r\n    return this._responses.get(url);\r\n  }\r\n\r\n  deleteResponse(url)\r\n  {\r\n    this._responses.delete(url);\r\n  }\r\n\r\n  incrementVideosPaused()\r\n  {\r\n    this._videosPaused += 1;\r\n  }\r\n\r\n  decreaseVideosPaused()\r\n  {\r\n    this._videosPaused -= 1;\r\n  }\r\n\r\n  getTotalVideosPaused()\r\n  {\r\n    return this._videosPaused;\r\n  }\r\n\r\n  addBlockedUrl(srcvideo)\r\n  {\r\n    this._blockedUrls.push(srcvideo);\r\n  }\r\n\r\n  containsBlockedUrl(srcvideo)\r\n  {\r\n    const item = this._blockedUrls.find(element =>\r\n      element._blockedUrl === srcvideo);\r\n    return item !== undefined;\r\n  }\r\n\r\n  addWhitelistedFrameId(frameId)\r\n  {\r\n    this._whitelistedFrameIds.push(frameId);\r\n  }\r\n\r\n  containsWhitelistedFrameId(frameId)\r\n  {\r\n    const item = this._whitelistedFrameIds.find(element =>\r\n      element === frameId);\r\n    return item !== undefined;\r\n  }\r\n\r\n  setUserLastClickDetails(time, coordinates)\r\n  {\r\n    this._lastClickTime = time;\r\n    this._lastClickCoordinates = coordinates;\r\n  }\r\n\r\n  getUserLastClickDetails()\r\n  {\r\n    return { lastClickTime: this._lastClickTime, lastClickCoordinates: this._lastClickCoordinates };\r\n  }\r\n\r\n  removeBlockedUrl(srcvideo)\r\n  {\r\n    for (let index = 0; index < this._blockedUrls.length; ++index)\r\n    {\r\n      if (this._blockedUrls[index] === srcvideo)\r\n      {\r\n        this._blockedUrls.splice(index, 1);\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  addVideoForResponseCaching(srcvideo)\r\n  {\r\n    this._responseCacheVideos.add(srcvideo);\r\n  }\r\n\r\n  hasVideoForResponseCaching(srcvideo)\r\n  {\r\n    return this._responseCacheVideos.has(srcvideo);\r\n  }\r\n\r\n  addClaimData(key, value)\r\n  {\r\n    if (value === 0)\r\n    {\r\n      return;\r\n    }\r\n    this._claimData.set(key, value);\r\n  }\r\n\r\n  getClaimData(key)\r\n  {\r\n    const iClaimedData = this._claimData.get(key);\r\n    this._claimData.delete(key);\r\n    return iClaimedData > 0 ? iClaimedData : 0;\r\n  }\r\n}\r\n","const Constants = {\r\n  // background script constants\r\n  UseNativeLogger: 'UseNativeLogger',\r\n\r\n  // content script constants\r\n\r\n  // The interval to consider when checking whether user click resulted in play of video\r\n  ClickPlayInterval: 4000,\r\n  BannerId: 'webboost_bannerid',\r\n  VideoId: 'webboost_videoid',\r\n  UserPlayed: 'webboost_userplayed',\r\n  ProcessedVideo: 'webboost_processed',\r\n  FoundPaused: 'webboost_found_paused'\r\n};\r\n\r\nexport default Constants;\r\n","/* eslint-disable no-undef */\r\nexport default class ExternalExtns\r\n{\r\n  constructor()\r\n  {\r\n    this._extnMap = new Map();\r\n    if (WEBPACK_BROWSER_TYPE === 'chrome')\r\n    {\r\n      this._extnMap.set('WebAdvisor', 'fheoggkfdfchfphceeifdbepaooicaho');\r\n    }\r\n    else if (WEBPACK_BROWSER_TYPE === 'firefox')\r\n    {\r\n      this._extnMap.set('WebAdvisor', '4ED1F68A-5463-4931-9384-8FFF5ED91D92');\r\n    }\r\n  }\r\n\r\n  isWhiteListed(extnId)\r\n  {\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    for (const id of this._extnMap.values())\r\n    {\r\n      if (id === extnId)\r\n      {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  get(extnName)\r\n  {\r\n    return this._extnMap.get(extnName);\r\n  }\r\n}\r\n","/* eslint-disable no-shadow */\r\nimport AutoPauseData from '../background/mcafee_wb_autopausedata';\r\nimport extension from '../../common/mcafee_wb_webextension';\r\nimport Utils from '../../common/mcafee_wb_utils';\r\n\r\nconst StorageConstants = {\r\n  LastFetchedTime: 'LastFetchedTime',\r\n  AutoPausedUrls: 'AutoPausedUrls',\r\n  AutoPauseEnabled: 'AutoPauseEnabled',\r\n  ShowWelcomePopup: 'ShowWelcomePopup',\r\n  ClientId: 'ClientId',\r\n  WhitelistFetchInterval: 24 * 60 * 60 * 1000 // 1 day interval\r\n};\r\n\r\nexport default class LocalStorage\r\n{\r\n  static _initfromlocalstorage(callback)\r\n  {\r\n    extension.storage.local.get(StorageConstants.AutoPausedUrls, (items) =>\r\n    {\r\n      this._autopausedata = items.AutoPausedUrls === undefined ? [] : items.AutoPausedUrls;\r\n      extension.storage.local.get(StorageConstants.AutoPauseEnabled, (items) =>\r\n      {\r\n        this._autopauseenabled = (\r\n          items.AutoPauseEnabled === undefined || items.AutoPauseEnabled === true\r\n        );\r\n        extension.storage.local.get(StorageConstants.ShowWelcomePopup, (items) =>\r\n        {\r\n          this._showWelcomePopup = items.ShowWelcomePopup;\r\n\r\n          if (undefined !== callback)\r\n          {\r\n            callback();\r\n          }\r\n        });\r\n      });\r\n    });\r\n\r\n    extension.storage.local.get(StorageConstants.ClientId, (items) =>\r\n    {\r\n      this._clientId = items.ClientId;\r\n    });\r\n\r\n    extension.storage.local.get('InstalledTime', (items) =>\r\n    {\r\n      if (undefined === items.InstalledTime)\r\n      {\r\n        const time = Date.now();\r\n        LocalStorage.setInstalledTime(time);\r\n        this._installedTime = time;\r\n      }\r\n      else\r\n      {\r\n        this._installedTime = items.InstalledTime;\r\n      }\r\n    });\r\n  }\r\n\r\n  static _hasDomain(domain, collection)\r\n  {\r\n    for (let index = 0; index < collection.length; ++index)\r\n    {\r\n      if (undefined !== collection[index].Url && domain === collection[index].Url)\r\n      {\r\n        return collection[index];\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  static _verifiedPauseData(data)\r\n  {\r\n    const finalData = {\r\n      BandWidthSaved: 0, IsWhiteListed: true, Url: '', VideosPaused: 0, UserModified: false\r\n    };\r\n    finalData.Url = data.Url;\r\n    return finalData;\r\n  }\r\n\r\n  static _mergeAutoPauseData(data)\r\n  {\r\n    if (undefined === data || undefined === data.length)\r\n    {\r\n      return;\r\n    }\r\n\r\n    // Take care of removing the entries that were removed from servers whitelist\r\n    for (let index = this._autopausedata.length - 1; index >= 0; --index)\r\n    {\r\n      // If user has modified the record locally then do nothing.\r\n\r\n      if (this._autopausedata[index].UserModified !== true)\r\n      {\r\n        // Check whether the whitelist from server has this domain that we locally have.\r\n        const pausedata = LocalStorage._hasDomain(this._autopausedata[index].Url, data);\r\n\r\n        // If the local domain name is absent in server then\r\n        if (pausedata === null)\r\n        {\r\n          // If the local domain entry has bandwidth or video paused data\r\n          // then just swith the whitelist info. Else remove the local record\r\n          const { bandWidthSaved, videosPaused } = this._autopausedata[index];\r\n          if (bandWidthSaved > 0 || videosPaused > 0)\r\n          {\r\n            this._autopausedata[index].IsWhiteListed = false;\r\n          }\r\n          else\r\n          {\r\n            this._autopausedata.splice(index, 1);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // Merge auto pause data with that locally available.\r\n\r\n    for (let index = 0; index < data.length; ++index)\r\n    {\r\n      if (undefined !== data[index].Url)\r\n      {\r\n        // If the received whitelist record is absent in the local auto pause data then add it\r\n        // If data is already available in collection then\r\n        const pausedata = LocalStorage._hasDomain(data[index].Url, this._autopausedata);\r\n\r\n        if (pausedata === null)\r\n        {\r\n          const finalData = LocalStorage._verifiedPauseData(data[index]);\r\n          this._autopausedata.push(finalData);\r\n        }\r\n      }\r\n    }\r\n\r\n    extension.storage.local.set({ AutoPausedUrls: data });\r\n  }\r\n\r\n  static _fetchData(firstTime)\r\n  {\r\n    extension.storage.local.set({ LastFetchedTime: Date.now() });\r\n\r\n    AutoPauseData.getAutoPauseData((isDefault, data) =>\r\n    {\r\n      // Donot merge default data if this is not the very first time\r\n      if (isDefault && !firstTime)\r\n      {\r\n        return;\r\n      }\r\n\r\n      // Get the data from local storage and then merge the one from server with\r\n      // the one locally available.\r\n      LocalStorage._initfromlocalstorage(() =>\r\n      {\r\n        LocalStorage._mergeAutoPauseData(data);\r\n        // Once merged, irrespective of whether there was any new data from server,\r\n        // just store it to persistent store.\r\n        extension.storage.local.set({ AutoPausedUrls: this._autopausedata });\r\n      });\r\n\r\n      // If this is the first time initialization of extension then set to default\r\n      if (firstTime)\r\n      {\r\n        extension.storage.local.set({ AutoPauseEnabled: true });\r\n        this._autopauseenabled = true;\r\n\r\n        extension.storage.local.set({ ShowWelcomePopup: true });\r\n        this._showWelcomePopup = true;\r\n      }\r\n    });\r\n  }\r\n\r\n  static _fetchPeriodically(interval)\r\n  {\r\n    setInterval(() =>\r\n    {\r\n      LocalStorage._fetchData(false);\r\n    }, interval);\r\n  }\r\n\r\n  static init()\r\n  {\r\n    extension.storage.local.get(StorageConstants.LastFetchedTime, (items) =>\r\n    {\r\n      const now = Date.now();\r\n      // If there is no last fetched time or if 1 day has elapsed after\r\n      // last fetch time then fetch default white list again\r\n      if (\r\n        items.LastFetchedTime === undefined\r\n        || ((items.LastFetchedTime + StorageConstants.WhitelistFetchInterval) < now)\r\n      )\r\n      {\r\n        // Fetch it immediately and thereafter at every interval period.\r\n        LocalStorage._fetchData(items.LastFetchedTime === undefined);\r\n        LocalStorage._fetchPeriodically(StorageConstants.WhitelistFetchInterval);\r\n      }\r\n      else\r\n      { // If already initialized then pick from storage.\r\n        LocalStorage._initfromlocalstorage();\r\n\r\n        // Calculate next fetch interval and then do a timer to fetch it\r\n        // then and therafter every interval.\r\n        const interval = StorageConstants.WhitelistFetchInterval - (now - items.LastFetchedTime);\r\n        setTimeout(() =>\r\n        {\r\n          LocalStorage._fetchData(false);\r\n          LocalStorage._fetchPeriodically(StorageConstants.WhitelistFetchInterval);\r\n        }, interval);\r\n      }\r\n    });\r\n  }\r\n\r\n  static setClientId(clientId)\r\n  {\r\n    this._clientId = clientId;\r\n    extension.storage.local.set({ ClientId: clientId });\r\n  }\r\n\r\n\r\n  static getClientId()\r\n  {\r\n    return this._clientId;\r\n  }\r\n\r\n  static setInstalledTime(time)\r\n  {\r\n    this._installedTime = time;\r\n    extension.storage.local.set({ InstalledTime: time });\r\n  }\r\n\r\n  static getInstalledTime()\r\n  {\r\n    return this._installedTime;\r\n  }\r\n\r\n\r\n  static getShowWelcomePopup()\r\n  {\r\n    return this._showWelcomePopup;\r\n  }\r\n\r\n  static setShowWelcomePopup()\r\n  {\r\n    this._showWelcomePopup = false;\r\n    extension.storage.local.set({ ShowWelcomePopup: false });\r\n  }\r\n\r\n  static setAutoPauseEnabled(autoPauseEnabled)\r\n  {\r\n    this._autopauseenabled = autoPauseEnabled;\r\n    extension.storage.local.set({ AutoPauseEnabled: this._autopauseenabled });\r\n  }\r\n\r\n  static getAutoPauseEnabled()\r\n  {\r\n    return this._autopauseenabled;\r\n  }\r\n\r\n  static getAllAutoPauseData()\r\n  {\r\n    return this._autopausedata;\r\n  }\r\n\r\n  static getAutoPauseData(srcvideo)\r\n  {\r\n    const domain = Utils.getDomainName(srcvideo);\r\n    if (!domain)\r\n    {\r\n      return null;\r\n    }\r\n    for (let index = 0; index < this._autopausedata.length; ++index)\r\n    {\r\n      if (domain.endsWith(this._autopausedata[index].Url))\r\n      {\r\n        return this._autopausedata[index];\r\n      }\r\n      if (this._autopausedata[index].Url.endsWith(domain))\r\n      {\r\n        // merge two domains if the incoming domain is a shorter version of saved domain\r\n        this._autopausedata[index].Url = domain;\r\n        extension.storage.local.set({ AutoPausedUrls: this._autopausedata });\r\n        return this._autopausedata[index];\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  static setAutoPauseData(srcvideo, paused, saved, wlisted)\r\n  {\r\n    const domain = Utils.getDomainName(srcvideo);\r\n    if (domain === null || undefined === domain)\r\n    {\r\n      return;\r\n    }\r\n\r\n    const wlistdata = LocalStorage.getAutoPauseData(srcvideo);\r\n    if (wlistdata === null)\r\n    {\r\n      const pausedata = {\r\n        BandWidthSaved: saved,\r\n        IsWhiteListed: wlisted === undefined ? false : wlisted,\r\n        Url: domain,\r\n        VideosPaused: paused,\r\n        UserModified: false\r\n      };\r\n      this._autopausedata.push(pausedata);\r\n    }\r\n    else\r\n    {\r\n      wlistdata.BandWidthSaved += saved;\r\n      wlistdata.VideosPaused += paused;\r\n      if (wlisted !== undefined)\r\n      {\r\n        wlistdata.IsWhiteListed = wlisted;\r\n        wlistdata.UserModified = true;\r\n      }\r\n    }\r\n    extension.storage.local.set({ AutoPausedUrls: this._autopausedata });\r\n  }\r\n\r\n  static getTotalVideosPaused()\r\n  {\r\n    let totalVideosPaused = 0;\r\n\r\n    for (let index = 0; index < this._autopausedata.length; ++index)\r\n    {\r\n      totalVideosPaused += this._autopausedata[index].VideosPaused;\r\n    }\r\n    return totalVideosPaused;\r\n  }\r\n\r\n  static getTotalBandwidthSaved()\r\n  {\r\n    let totalBandwidthSaved = 0;\r\n\r\n    for (let index = 0; index < this._autopausedata.length; ++index)\r\n    {\r\n      totalBandwidthSaved += this._autopausedata[index].BandWidthSaved;\r\n    }\r\n    return totalBandwidthSaved;\r\n  }\r\n\r\n  static get(name, callback)\r\n  {\r\n    extension.storage.local.get(name, (result) =>\r\n    {\r\n      callback(result[name]);\r\n    });\r\n  }\r\n}\r\n","import extension from '../../../common/mcafee_wb_webextension';\r\n\r\nconst aboutModule = angular.module('webboost-extension');\r\n\r\naboutModule.controller('aboutController', ['$scope', ($scope) =>\r\n{\r\n  // fetch locale\r\n  const _localeData = function (attr)\r\n  {\r\n    return extension.i18n.getMessage(attr);\r\n  };\r\n\r\n  // about content data\r\n  $scope.aboutData = {\r\n    pageTitle: _localeData('navigation_header_about'),\r\n    privacyTitle: _localeData('about_Privacy_Title'),\r\n    privacyLink: _localeData('about_Privacy_Link'),\r\n    licenseTitle: _localeData('about_License_Title'),\r\n    licenseLink: _localeData('about_License_Link'),\r\n    brandName: _localeData('brand_Name'),\r\n    extName: _localeData('ext_Name'),\r\n    copyRight: _localeData('about_Brand_Copy_rights')\r\n  };\r\n}]);\r\n","/* eslint-disable no-param-reassign */\r\n/* eslint-disable no-underscore-dangle */\r\nimport { Helper } from '../../../common/mcafee_wb_helper';\r\nimport TelemetryWhitelist from '../../../common/telemetry/mcafee_wb_whitelist';\r\nimport extension from '../../../common/mcafee_wb_webextension';\r\n\r\nconst autoPauseModule = angular.module('webboost-extension');\r\nautoPauseModule.controller('autoPauseController', ['$scope', '$stateParams', '$timeout', ($scope, $stateParams, $timeout) =>\r\n{\r\n  // fetch locale\r\n  const _localeData = function (attr)\r\n  {\r\n    return extension.i18n.getMessage(attr);\r\n  };\r\n\r\n  // content\r\n  $scope.pageContent = {\r\n    titleInitial: _localeData('autoPause_Initial_Title'),\r\n    subTitleInitial: _localeData('autoPause_Initial_SubTitle'),\r\n    initialNoListTextFirst: _localeData('autoPause_Initial_Nolist_FirstLine'),\r\n    initialNoListTextSecond: _localeData('autoPause_Initial_Nolist_SecondLine'),\r\n\r\n    titleActive: _localeData('autoPause_Active_Title'),\r\n    subTitleActive: _localeData('autoPause_Active_SubTitle'),\r\n\r\n    titleDeactive: _localeData('autoPause_Deactive_Title'),\r\n    subTitleDeactive: _localeData('autoPause_Deactive_SubTitle'),\r\n    subTitleDeactiveLink: _localeData('autoPause_Deactive_SubTitle_Link'),\r\n\r\n    titleWhitelisted: _localeData('autoPause_Whitelisted_Title'),\r\n\r\n    buttonAllowAutoPlay: _localeData('autoPause_Whitelist_Button_AllowAutoPlay'),\r\n    buttonStopAutoPlay: _localeData('autoPause_Whitelist_Button_StopAutoPlay'),\r\n\r\n    tableTotal: _localeData('autoPause_Table_Data_Total'),\r\n    tableVideosStopped: _localeData('autoPause_Table_Data_TotalVideosStopped'),\r\n    tableSavedData: _localeData('autoPause_Table_Data_TotalVideosSaved'),\r\n    tableHeaderWebsite: _localeData('autoPause_Table_Header_Website'),\r\n    tableHeaderVideosStopped: _localeData('autoPause_Table_Header_VideosStopped'),\r\n    tableHeaderDataSaved: _localeData('autoPause_Table_Header_DataSaved'),\r\n\r\n    tableHoverAllowAutoPlay: _localeData('autoPause_Whitelist_Button_AllowAutoPlay'),\r\n    tableHoverStopAutoPlay: _localeData('autoPause_Whitelist_Button_StopAutoPlay'),\r\n\r\n    tableDataSavedSubMessage: _localeData('autoPause_Table_Header_DataSaved_Message'),\r\n\r\n    noInfo: _localeData('autoPause_Unit_No_Info')\r\n  };\r\n\r\n  // hide auto pause listing at default\r\n  $scope.isListingVisible = false;\r\n  $scope.isToggled = false;\r\n  $scope.isThisDisable = true; // disable as default or if the page is not of proper url\r\n  $scope.loadingData = true;\r\n\r\n  const sendTelemetry = function (url, addToWhitelist)\r\n  {\r\n    if (!addToWhitelist)\r\n    {\r\n      return;\r\n    }\r\n\r\n    const domain = Helper.getDomainName(url);\r\n\r\n    // send telemetry\r\n    const telemetry = new TelemetryWhitelist().interaction_type('Add').browser('CH').domain(domain)\r\n      .serialize();\r\n    extension.runtime.sendMessage(\r\n      {\r\n        action: 'SendTelemetry',\r\n        telemetry\r\n      }\r\n    );\r\n  };\r\n\r\n  // whitelisting function\r\n  const whitelistingFn = function (whiteListedUrl, whiteListedStatus)\r\n  {\r\n    extension.runtime.sendMessage(\r\n      {\r\n        action: 'UpdateWhitelist',\r\n        whiteListedUrl,\r\n        whiteListedStatus\r\n      }, () =>\r\n      {}\r\n    );\r\n  };\r\n\r\n  // set data\r\n  const setData = function (data)\r\n  {\r\n    $scope.totalVideosPaused = data.totalVideosPaused;\r\n    $scope.pausedInThisSession = data.pausedInThisSession ? data.pausedInThisSession : 0;\r\n    $scope.autoPausedDataList = data.autoPausedDataList;\r\n    $scope.totalBandwidthSaved = data.totalBandwidthSaved;\r\n    $scope.isCurrentWhiteListed = data.isHostWhiteListed;\r\n    $scope.showWelcomePopup = data.showWelcomePopup;\r\n    $scope.globalAutoPauseEnabled = data.globalAutoPauseEnabled;\r\n\r\n    if (data.currentUrl !== '' && data.currentUrl !== undefined && data.currentUrl !== null)\r\n    {\r\n      $scope.currentUrl = data.currentUrl;\r\n      $scope.isThisDisable = false;\r\n    }\r\n\r\n    if (!$scope.$$phase)\r\n    {\r\n      $scope.$digest();\r\n    }\r\n\r\n    // Show main UI after a small delay after the data has been loaded\r\n    $timeout(() =>\r\n    {\r\n      $scope.loadingData = false;\r\n    }, 200);\r\n  };\r\n\r\n  // refresh the data\r\n  const refreshAutoPauseData = function ()\r\n  {\r\n    extension.runtime.sendMessage(\r\n      {\r\n        action: 'GetAllAutoPauseData'\r\n      }, (response) =>\r\n      {\r\n        setData(response);\r\n      }\r\n    );\r\n  };\r\n\r\n  // reload current page\r\n  const reloadPage = function ()\r\n  {\r\n    extension.tabs.query(\r\n      {\r\n        active: true,\r\n        currentWindow: true\r\n      }, (arrayOfTabs) =>\r\n      {\r\n        extension.tabs.reload(arrayOfTabs[0].id);\r\n      }\r\n    );\r\n  };\r\n\r\n  // on click show auto pause listing\r\n  $scope.toggleListing = function toggleListing()\r\n  {\r\n    $scope.isListingVisible = !$scope.isListingVisible;\r\n    $scope.isToggled = !$scope.isToggled;\r\n  };\r\n\r\n  // Toggle white-list-btn\r\n  $scope.toggleWhitelist = function toggleWhitelist(currentUrl)\r\n  {\r\n    $scope.isCurrentWhiteListed = !$scope.isCurrentWhiteListed;\r\n    whitelistingFn(currentUrl, $scope.isCurrentWhiteListed);\r\n    refreshAutoPauseData();\r\n    sendTelemetry(currentUrl, $scope.isCurrentWhiteListed);\r\n    reloadPage();\r\n  };\r\n\r\n  // listing URL whitelisting\r\n  $scope.whitelistThis = function whitelistThis(indexData, indexUrl)\r\n  {\r\n    indexData.IsWhiteListed = !indexData.IsWhiteListed;\r\n    $scope.isCurrentWhiteListed = indexData.IsWhiteListed;\r\n    whitelistingFn(indexUrl, indexData.IsWhiteListed);\r\n    sendTelemetry(indexUrl, indexData.IsWhiteListed);\r\n    refreshAutoPauseData();\r\n\r\n    // reload the page only if the active tab url is the same being whitelisted\r\n    if ($scope.currentUrl.includes(indexUrl))\r\n    {\r\n      reloadPage();\r\n    }\r\n  };\r\n\r\n  $scope.enableGlobalAutoPause = function enableGlobalAutoPause()\r\n  {\r\n    $scope.globalAutoPauseEnabled = true;\r\n    extension.runtime.sendMessage(\r\n      {\r\n        action: 'UpdateGlobalAutoPause',\r\n        enabled: $scope.globalAutoPauseEnabled\r\n      }, () =>\r\n      {}\r\n    );\r\n  };\r\n\r\n  // sorting function\r\n  $scope.propertyName = 'BandWidthSaved';\r\n  $scope.videosPausedAscending = false;\r\n  $scope.dataSavedAscending = true;\r\n  $scope.ascending = true;\r\n\r\n  $scope.sortBy = function sortBy(propertyName)\r\n  {\r\n    if (!$scope.globalAutoPauseEnabled)\r\n    {\r\n      return;\r\n    }\r\n\r\n    $scope.propertyName = propertyName;\r\n\r\n    if (propertyName === 'VideosPaused')\r\n    {\r\n      $scope.videosPausedAscending = !$scope.videosPausedAscending;\r\n      $scope.ascending = $scope.videosPausedAscending;\r\n      return;\r\n    }\r\n\r\n    $scope.dataSavedAscending = !$scope.dataSavedAscending;\r\n    $scope.ascending = $scope.dataSavedAscending;\r\n  };\r\n\r\n  if ($stateParams.myParam !== null)\r\n  {\r\n    setData($stateParams.myParam);\r\n\r\n    // Run only once. this is to turn off the flag so the initial\r\n    // welcome UI does not show again later\r\n    if ($scope.showWelcomePopup)\r\n    {\r\n      extension.runtime.sendMessage(\r\n        {\r\n          action: 'TurnOffWelcomePopup'\r\n        }, () =>\r\n        {}\r\n      );\r\n    }\r\n  }\r\n}]);\r\n","import extension from '../../../common/mcafee_wb_webextension';\r\n\r\nconst faqModule = angular.module('webboost-extension');\r\nfaqModule.controller('faqController', ['$scope', ($scope) =>\r\n{\r\n  const _localeData = function (attr)\r\n  {\r\n    return extension.i18n.getMessage(attr);\r\n  };\r\n\r\n  $scope.faqContent = {\r\n    QA: [],\r\n    faqText: _localeData('navigation_header_faq')\r\n  };\r\n\r\n  // populate faq questions/answers\r\n  for (let i = 1; i <= 4; i++)\r\n  {\r\n    const question = _localeData(`faq_Question_${i}`);\r\n    const answer = _localeData(`faq_Answer_${i}`);\r\n    $scope.faqContent.QA.push(\r\n      {\r\n        question,\r\n        answer\r\n      }\r\n    );\r\n  }\r\n\r\n  if (!$scope.$$phase)\r\n  {\r\n    $scope.$digest();\r\n  }\r\n}]);\r\n","/* eslint-disable no-restricted-syntax */\r\nimport extension from '../../../common/mcafee_wb_webextension';\r\n\r\nconst whiteListModule = angular.module('webboost-extension');\r\nwhiteListModule.controller('whiteListController', ['$scope', '$timeout', ($scope, $timeout) =>\r\n{\r\n  // fetch locale\r\n  const _localeData = function (attr)\r\n  {\r\n    return extension.i18n.getMessage(attr);\r\n  };\r\n\r\n  // page content\r\n  $scope.pageContent = {\r\n    toggleTitle: _localeData('navigation_header_whitelist'),\r\n    toggleText: _localeData('whitelist_Toggle_Text'),\r\n    removeSuccessMessage: _localeData('whiteList_Remove_Success_Message'),\r\n    listingTitle: _localeData('whiteList_Url_Listing_title'),\r\n    emptyListMessage: _localeData('whiteList_Empty_List_Message')\r\n  };\r\n\r\n  $scope.showNotification = false;\r\n  $scope.isListEmpty = true;\r\n\r\n  const notify = function (url, status)\r\n  {\r\n    // notification\r\n    $scope.showNotification = true;\r\n    // hide notification after 5 sec\r\n    $timeout(() =>\r\n    {\r\n      $scope.showNotification = false;\r\n    }, 5000);\r\n\r\n    // check if url is disabled or enabled\r\n    if (!status)\r\n    {\r\n      $scope.notifyMessage = url;\r\n    }\r\n  };\r\n\r\n  const setData = function (data)\r\n  {\r\n    $scope.autoPausedDataList = data.autoPausedDataList;\r\n    $scope.globalAutoPauseEnabled = data.globalAutoPauseEnabled;\r\n    let listCount = 0;\r\n    for (const item of $scope.autoPausedDataList)\r\n    {\r\n      if (item.IsWhiteListed)\r\n      {\r\n        $scope.isListEmpty = false;\r\n      }\r\n      else\r\n      {\r\n        listCount += 1;\r\n        if (listCount === $scope.autoPausedDataList.length)\r\n        {\r\n          $scope.isListEmpty = true;\r\n        }\r\n      }\r\n    }\r\n    $scope.$digest();\r\n  };\r\n\r\n  const getAllAutoPauseData = function ()\r\n  {\r\n    extension.runtime.sendMessage(\r\n      {\r\n        action: 'GetAllAutoPauseData'\r\n      }, (response) =>\r\n      {\r\n        setData(response);\r\n      }\r\n    );\r\n  };\r\n\r\n  // Handle toggle button\r\n  $scope.autoPlayToggle = function autoPlayToggle()\r\n  {\r\n    $scope.globalAutoPauseEnabled = !$scope.globalAutoPauseEnabled;\r\n    extension.runtime.sendMessage(\r\n      {\r\n        action: 'UpdateGlobalAutoPause',\r\n        enabled: $scope.globalAutoPauseEnabled\r\n      }, () =>\r\n      {}\r\n    );\r\n  };\r\n\r\n  // Remove from whitelist\r\n  $scope.removeFromWhitelist = function removeFromWhitelist(whiteListedUrl)\r\n  {\r\n    extension.runtime.sendMessage(\r\n      {\r\n        action: 'UpdateWhitelist',\r\n        whiteListedUrl,\r\n        whiteListedStatus: false\r\n      }, () =>\r\n      {}\r\n    );\r\n\r\n    // notification\r\n    notify(whiteListedUrl, false);\r\n    getAllAutoPauseData();\r\n  };\r\n\r\n  // Add to whitelisting\r\n  $scope.submitThis = function submitThis(whiteListedUrl)\r\n  {\r\n    extension.runtime.sendMessage(\r\n      {\r\n        action: 'UpdateWhitelist',\r\n        whiteListedUrl,\r\n        whiteListedStatus: true\r\n      }, () =>\r\n      {\r\n        getAllAutoPauseData();\r\n      }\r\n    );\r\n  };\r\n\r\n  // initial\r\n  getAllAutoPauseData();\r\n}]);\r\n","/* eslint-disable no-underscore-dangle */\r\nimport TelemetryScreenShown from '../../../common/telemetry/mcafee_wb_screen_shown';\r\nimport extension from '../../../common/mcafee_wb_webextension';\r\n\r\nconst windowModule = angular.module('webboost-extension');\r\nwindowModule.controller('WindowController', ['$scope', '$transitions', ($scope, $transitions) =>\r\n{\r\n  const _localeData = function (attr)\r\n  {\r\n    return extension.i18n.getMessage(attr);\r\n  };\r\n\r\n  const sendTelemetry = function (name)\r\n  {\r\n    // mapping screen names with telemetry interaction names\r\n    const telemetryInteractions = {\r\n      // eslint-disable-next-line camelcase\r\n      auto_pause_setting: 'Settings',\r\n      faq: 'FAQ',\r\n      about: 'About'\r\n    };\r\n\r\n    const interaction = telemetryInteractions[name];\r\n    if (interaction === undefined)\r\n    {\r\n      return;\r\n    }\r\n\r\n    // send telemetry\r\n    const telemetry = new TelemetryScreenShown().interaction_type(interaction).browser('CH').serialize();\r\n    extension.runtime.sendMessage(\r\n      {\r\n        action: 'SendTelemetry',\r\n        telemetry\r\n      }\r\n    );\r\n  };\r\n\r\n  $scope.pageContent = {\r\n    whitelistText: _localeData('navigation_header_whitelist'),\r\n    aboutText: _localeData('navigation_header_about'),\r\n    faqText: _localeData('navigation_header_faq')\r\n  };\r\n\r\n  $scope.isMenuVisible = false;\r\n\r\n  $scope.showMenu = function showMenu()\r\n  {\r\n    $scope.isMenuVisible = !$scope.isMenuVisible;\r\n  };\r\n\r\n  $scope.closePopup = function closePopup()\r\n  {\r\n    window.close();\r\n  };\r\n\r\n  $transitions.onStart({}, (transition) =>\r\n  {\r\n    sendTelemetry(transition.to().name);\r\n    $scope.isMenuVisible = false;\r\n  });\r\n}]);\r\n"],"sourceRoot":""}